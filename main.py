# Задание №1 DES
# ЧЕРНЫШЯН ЮРЬЕВИЧ
# 1101 0111 1100 0101 1101 0000 1100 1101
# 1101 1011 1101 1000 1101 1111 1100 1101
# После перестановки
# (1111 1111) (0111 0101) (1100 1011) (1101 1011) - L0
# (1111 1111) (0000 0000) (1111 1000) (0101 0001) - R0
# Расширенный подблок R-48 бит:
# 111111 111110 100000 000001 011111 110000 001010 100011
# Ключ: ЮРЬЕВИЧЯ
# 11011110 11010000 11011100 11000101 11000010 11001000 11010111 11011111(64 бит)
# Вычеркиваем 8 бит:
# 1101111 1101000 1101110 1100010 1100001 1100100 1101011 1101111(56 бит)
# 11011111 10100011 01110110 00101100 00111001 00110101 11101111
# Ключ раунда:
# 110111 110100 010111 011001 011000 111000 011010 111011(48 бит)
# Поразрядное суммирование:
# R:111111 111110 100000 000001 011111 110000 001010 100011
# K:110111 110100 010111 011001 011000 111000 011010 111011
# -----------------------------------------------------------
#  001000 001010 110111 011000 000111 001000 010000 011000
# S1:2=0010 S2:11=1011 S3:3=0011 S4:11=1011 S5:12=1100 S6:9=1001 S7:3=0011 S8:5=0101
# 32 Выходных бита:
# 0010 1011 0011 1011 1100 1001 0011 0101
# Перестановка:
# R0:1101 0111 0100 1100 0110 1110 0110 0100
# Поразрдяное суммирование:
# R0:1101 0111 0100 1100 0110 1110 0110 0100
# L0:1111 1111 0111 0101 1100 1011 1101 1011
# ------------------------------------------
# R1:0010 1000 0011 1001 1010 0101 1011 1111
# Записываем полученные подблоки:
# L1=R0:1111 1111 0000 0000 1111 1000 0101 0001
#    R1:0010 1000 0011 1001 1010 0101 1011 1111
# ---------------------------------------------
# 1111 1111 0000 0000 1111 1000 0101 0001 0010 1000 0011 1001 1010 0101 1011 1111
# Итоговая операция перестановки:
# 1111111100000000111110000101000100101000001110011010010110111111
# 01101011 01000010 01001010 11100110 01100111 11101110 01000101 01001110
Permutation_1 = [58, 50, 42, 34, 26, 18, 10, 2,
                 60, 52, 44, 26, 28, 20, 12, 4,
                 62, 54, 46, 38, 30, 22, 14, 6,
                 64, 56, 48, 40, 32, 24, 16, 8,
                 57, 49, 41, 33, 25, 17, 9, 1,
                 59, 51, 43, 35, 27, 19, 11, 3,
                 61, 53, 45, 37, 29, 21, 13, 5,
                 63, 55, 47, 39, 31, 23, 15, 7]

Permutation_2 = [32, 1, 2, 3, 4, 5,
                 4, 5, 6, 7, 8, 9,
                 8, 9, 10, 11, 12, 13,
                 12, 13, 14, 15, 15, 17,
                 16, 17, 18, 19, 20, 21,
                 20, 21, 22, 23, 24, 25,
                 24, 25, 26, 27, 28, 29,
                 28, 29, 30, 31, 32, 1]
S1 = [[14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7],
      [0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8],
      [4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0],
      [15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13]]

S2 = [[15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10],
      [3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5],
      [0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15],
      [13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9]]

S3 = [[10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8],
      [13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1],
      [13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7],
      [1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12]]

S4 = [[7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15],
      [13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9],
      [10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4],
      [3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14]]

S5 = [[2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9],
      [14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6],
      [4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14],
      [11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3]]

S6 = [[12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11],
      [10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8],
      [9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6],
      [4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13]]

S7 = [[4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1],
      [13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6],
      [1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2],
      [6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12]]

S8 = [[13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7],
      [1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9, 2],
      [7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8],
      [2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11]]

P_block = [16, 7, 20, 21, 29, 12, 28, 17,
           1, 15, 23, 2, 5, 18, 31, 10,
           2, 8, 24, 14, 32, 27, 3, 9,
           19, 13, 30, 6, 22, 11, 4, 25]

Final_table = [40, 8, 48, 16, 56, 24, 64, 32,
               39, 7, 47, 15, 55, 23, 63, 31,
               38, 6, 46, 14, 54, 22, 62, 30,
               37, 5, 45, 13, 53, 21, 61, 29,
               36, 4, 44, 12, 52, 20, 60, 28,
               35, 3, 43, 11, 51, 19, 59, 27,
               34, 2, 42, 10, 50, 18, 58, 26,
               33, 1, 41, 9, 49, 17, 57, 25]

GOST_table = [[1, 13, 4, 6, 7, 5, 14, 4],
              [15, 11, 11, 12, 13, 8, 11, 10],
              [13, 4, 10, 7, 10, 1, 4, 9],
              [0, 1, 0, 1, 1, 13, 12, 2],
              [5, 3, 7, 5, 0, 10, 6, 13],
              [7, 15, 2, 15, 8, 3, 13, 8],
              [10, 5, 1, 13, 9, 4, 15, 0],
              [4, 9, 13, 8, 15, 2, 10, 14],
              [9, 0, 3, 4, 14, 14, 2, 6],
              [2, 10, 6, 10, 4, 15, 3, 11],
              [3, 14, 8, 9, 6, 12, 8, 1],
              [14, 7, 5, 14, 12, 7, 1, 12],
              [6, 6, 9, 0, 11, 6, 0, 7],
              [11, 8, 12, 3, 2, 0, 7, 15],
              [8, 2, 15, 11, 5, 9, 5, 5],
              [12, 12, 14, 2, 3, 11, 9, 3]]
dictonary = {"А": 1, "Б": 2, "В": 3, "Г": 4, "Д": 5,
             "Е": 6, "Ё": 7, "Ж": 8, "З": 9, "И": 10,
             "Й": 11, "К": 12, "Л": 13, "М": 14, "Н": 15,
             "О": 16, "П": 17, "Р": 18, "С": 19, "Т": 20,
             "У": 21, "Ф": 22, "Х": 23, "Ц": 24, "Ч": 25,
             "Ш": 26, "Щ": 27, "Ъ": 28, "Ы": 29, "Ь": 30,
             "Э": 31, "Ю": 32, "Я": 33}
dictonary_2 = {1: "А", 2: "Б", 3: "В", 4: "Г", 5: "Д", 6: "Е",
               7: "Ё", 8: "Ж", 9: "З", 10: "И", 11: "Й", 12: "К",
               13: "Л", 14: "М", 15: "Н", 16: "О", 17: "П", 18: "Р",
               19: "С", 20: "Т", 21: "У", 22: "Ф", 23: "Х", 24: "Ц",
               25: "Ч", 26: "Ш", 27: "Щ", 28: "Ъ", 29: "Ы", 30: "Ь",
               31: "Э", 32: "Ю", 33: "Я"}


def DES(message, key):
    result = ""
    for i in list(message.encode('cp1251')):
        result += bin(i)[2:]
    KEY = ""
    for i in list(key.encode('cp1251')):
        KEY += bin(i)[2:]
    print("1.Двоичный вид сообщения:")
    print(' '.join([result[i:i + 4] for i in range(0, len(result), 4)]))
    Permutation_result = ""
    for i in Permutation_1:
        Permutation_result += result[i - 1]
    Permutation_mas = [Permutation_result[i:i + 4] for i in range(0, len(Permutation_result), 4)]
    print("2.Выполним перестановку исходного сообщения согласно таблице:")
    print(' '.join(Permutation_mas))
    L0 = ' '.join(Permutation_mas[:8])
    R0 = ' '.join(Permutation_mas[8:16])
    print("3.Разбиваем блок пополам:", "L0- " + L0, "R0- " + R0, sep='\n')
    print("4.Расширим правый подблок R0 в 48-битовый согласно таблице расширения:")
    R0 = ''.join(R0.split())
    R0_Advanced = ""
    for i in Permutation_2:
        R0_Advanced += R0[i - 1]
    print(' '.join([R0_Advanced[i:i + 6] for i in range(0, len(R0_Advanced), 6)]))
    print("5.Выбираем 56-битный ключ (Отчество) с битами проверки (всего 64 бит) и генерируем 48-битный ключ раунда:",
          'ЮРЬЕВИЧЯ', sep='\n')
    print(' '.join([KEY[i:i + 8] for i in range(0, len(KEY), 8)]))
    print("Вычеркиваем каждый восьмой бит в блоках и получим фактический ключ шифра длиной в 56 бит:")
    KEY_split = ''.join(KEY.split())
    KEY_split = KEY_split[:7] + KEY_split[8:15] + KEY_split[16:23] + KEY_split[24:31] + KEY_split[32:39] + KEY_split[
                                                                                                           40:47] + KEY_split[
                                                                                                                    48:55] + KEY_split[
                                                                                                                             56:63]
    print(' '.join([KEY_split[i:i + 7] for i in range(0, len(KEY_split), 7)]))
    KEY_round = ''.join(KEY_split.split())
    KEY_round = KEY_round[:7] + KEY_round[8:15] + KEY_round[16:23] + KEY_round[24:31] + KEY_round[32:39] + KEY_round[
                                                                                                           40:47] + KEY_round[
                                                                                                                    48:54]
    print("Ключ раунда:")
    print(' '.join([KEY_round[i:i + 6] for i in range(0, len(KEY_round), 6)]))
    print("6.Сложим расширенный R0 по mod2 c блоком ключа:")
    f = ""
    for i in range(len(R0_Advanced)):
        f += str((int(R0_Advanced[i]) + int(KEY_round[i])) % 2)
    print(' '.join([f[i:i + 6] for i in range(0, len(f), 6)]))
    print("7. S-преобразование:")
    S = ""
    NUM_BLOCK = 1
    for i in range(0, len(f), 6):
        STR = int((f[i] + f[i + 5]), 2)
        CLMN = int(f[i + 1:i + 5], 2)
        S_block = ""
        match NUM_BLOCK:
            case 1:
                S_block += str(bin(S1[STR][CLMN])[2:])
            case 2:
                S_block += str(bin(S2[STR][CLMN])[2:])
            case 3:
                S_block += str(bin(S3[STR][CLMN])[2:])
            case 4:
                S_block += str(bin(S4[STR][CLMN])[2:])
            case 5:
                S_block += str(bin(S5[STR][CLMN])[2:])
            case 6:
                S_block += str(bin(S6[STR][CLMN])[2:])
            case 7:
                S_block += str(bin(S7[STR][CLMN])[2:])
            case 8:
                S_block += str(bin(S8[STR][CLMN])[2:])
        while len(S_block) < 4:
            S_block = "0" + S_block
        S += S_block
        NUM_BLOCK += 1
    print(S)
    print("8.Подвергаем 32 выходных бита из S-блоков прямой перестановке с правилом, показанным в P-блоке:")
    R0_new = ""
    for i in P_block:
        R0_new += S[i - 1]
    print(' '.join([R0_new[i:i + 4] for i in range(0, len(R0_new), 4)]))
    print("9.Производим операцию поразрядного суммирования:")
    R1 = ""
    L0 = ''.join(L0.split())
    for i in range(len(R0_new)):
        R1 += str((int(R0_new[i]) + int(L0[i])) % 2)
    print(' '.join([R1[i:i + 4] for i in range(0, len(R1), 4)]))
    print("10.Конкатенируем L1 = R0 и R1:")
    print(' '.join([(R0 + R1)[i:i + 4] for i in range(0, len(R0 + R1), 4)]))
    L1 = R0 + R1
    print(L1)
    Result = ""
    m = 0
    for i in Final_table:
        Result += L1[i - 1]
        if (len(Result) - m) % 8 == 0:
            Result += " "
            m += 1
    print("Результат выполнения перестановки:")
    print(Result)


# Задание №2 Алгоритм шифрования ГОСТ 28147-89
# Исходные данные: ЧЕРНЫШЯН
# Ключ: РАСТворокерамзитобетоносмеситель (переделать под ЮРЬЕ)
# 1101 0111 1100 0101 1101 0000 1100 1101 - L0
# 1101 1011 1101 1000 1101 1111 1100 1101 - R0
# РАСТ
# 1101 0000 1100 0000 1101 0001 1101 0010 - X0
# 1.R0+X0 mod 2^32:
#     11 1   111 1       1 1 11 1111 1
# R0 - 1101 1011 1101 1000 1101 1111 1100 1101
# X0 - 1101 0000 1100 0000 1101 0001 1101 0010
# ---------------------------------------------
# mod 2^32 1010 1100 1001 1001 1011 0001 1001 1111
# После перестанвоки:
# 3 6 6 10 12 8 3 3
# 0011 0110 0110 1010 1100 1000 0011 0011
# f (R0,X0):
# 0101 0110 0100 0001 1001 1001 1011 0011
# R1= f(R0,X0) ⊕ L0:
# L0:1101 0111 1100 0101 1101 0000 1100 1101
# f :0101 0110 0100 0001 1001 1001 1011 0011
# --------------------------------------------
#    1000 0001 1000 0100 0100 1001 0111 1110
# Ответ:
# L1=R0: 1101 1011 1101 1000 1101 1111 1100 1101
#    R1: 1000 0001 1000 0100 0100 1001 0111 1110
def GOST(message, key):
    print("Исходные данные: " + message)
    print("Ключ:" + key[:4].upper())
    print("Перевод исходных данных:")
    message_bin = ""
    for i in list(message.encode('cp1251')):
        message_bin += bin(i)[2:]
    R0 = ' '.join([message_bin[32:64][i:i + 4] for i in range(0, len(message_bin[32:64]), 4)])
    print(R0 + "-R0")
    L0 = ' '.join([message_bin[:32][i:i + 4] for i in range(0, len(message_bin[:32]), 4)])
    print(L0 + "-L0")
    key_bin = ""
    print("Первый подключ X0:")
    for i in list(key[:4].upper().encode('cp1251')):
        key_bin += bin(i)[2:]
    X0 = ' '.join([key_bin[i:i + 4] for i in range(0, len(key_bin), 4)])
    print(X0 + "-X0")
    print("1.Вычисление суммы R0 и X0 по mod 𝟐^32: ")
    R0 = ''.join(R0.split())
    X0 = ''.join(X0.split())
    res = ""
    m = 0
    for i in range(len(R0), 0, -1):
        check = int(R0[i - 1]) + int(X0[i - 1])
        if check + m >= 2:
            if check + m == 2:
                res += "0"
            elif check + m > 2:
                res += "1"
            else:
                res += "0"
            m = 1
        else:
            res += str(check + m)
            m = 0
    res = ''.join(reversed(res))
    print(' '.join([res[i:i + 4] for i in range(0, len(res), 4)]))
    print("2.Перестановка:")
    column = 0
    testik = ''.join(res)
    result1 = ""
    result2 = ""
    result_2 = ""
    for i in range(0, len(testik), 4):
        stroka = int(testik[i:i + 4], 2)
        result1 += str(GOST_table[stroka][column]) + " "
        result_2 = bin(GOST_table[stroka][column])[2:]
        while len(result_2) < 4:
            result_2 = "0" + result_2
        result2 += result_2
        column += 1
    print("Результат " + result1)
    print("Результат " + ' '.join([result2[i:i + 4] for i in range(0, len(result2), 4)]))
    print("3.Выполним циклический сдвиг результата п.2 на 11 бит влево")
    f = result2[11:] + result2[:11]
    print(' '.join([f[i:i + 4] for i in range(0, len(f), 4)]))
    print("4.Вычисляем R1= f(R0,X0) ⊕ L0:")
    R1 = ""
    L0 = ''.join(L0.split())
    f = ''.join(f.split())
    for i in range(len(L0)):
        R1 += str((int(L0[i]) + int(f[i])) % 2)
    print(' '.join([R1[i:i + 4] for i in range(0, len(R1), 4)]))
    R0 = ' '.join([R0[i:i + 4] for i in range(0, len(R0), 4)])
    R1 = ' '.join([R1[i:i + 4] for i in range(0, len(R1), 4)])
    print("Ответ:", "L1=R0:" + R0, "R1:   " + R1, sep="\n")


# Задание №3 Алгоритм шифрования RSA
# 1. Генерация ключей:
# p = 89 q = 13 n=pq=1157
# Функция Эйлера:
# f(n) = (p-1)(q-1)=88*12=1056
# Закрытый ключ d выбираем из условий d < (n) и d взаимно просто с (n)
# d = 283
# Выбираем открытый ключ е из условий e < (n) и d*e = 1(mod  (n))
# Таким образом для расчета e решим уравнение
# 283e=1(mod 1056)
# 283e-1=1056k
# 283e=1056k+1
# e=(1056k+1)/283 => e=403 k=108
# (403,1157) - открытый ключ
# (283,1157) - закрытый ключ
# 2. Шифрование
# Ч-25 Я-33 Ю-32
# C1=(25^403) mod 1157 = 467
# C2=(33^403) mod 1157 = 903
# C3=(32^403) mod 1157 = 449
# (25,33,32) => (467,903,606)
# 3. Расшифрование:
# М1=(467^283) mod 1157 = 25
# М2=(903^283) mod 1157 = 33
# М3=(606^283) mod 1157 = 32

def RSA(FIO, p, q, d):
    print("Исходное сообщение - " + FIO)
    print("1.Генерация ключей:")
    print("Фунция Эйлера:")
    f = (p - 1) * (q - 1)
    print("φ(n)=" + str(f))
    k = 0
    n = p * q
    e = 0.1
    while e != int(e):
        k += 1
        e = (f * k + 1) / d
    print("Простой ключ: d=" + f'{d}')
    print("Открытый ключ: ", f'{d}' + "e-1=" + f'{f}' + "k", sep="\n")
    print("При к =" + f'{k}' + ", " + "e=" + f'{int(e)}')
    print("(" + f'{int(e)}' + "," + f'{n}' + ")" + "- открытый ключ")
    print("(" + f'{d}' + "," + f'{n}' + ")" + "- закрытый ключ")
    print("2.Шифрование:")
    FIO_code = []
    for i in FIO:
        FIO_code.append(str(dictonary[i]))
    print(FIO[0] + "-" + FIO_code[0] + " " + FIO[1] + "-" + FIO_code[1] + " " + FIO[2] + "-" + FIO_code[2])
    print("Зашифруем сообщение, используя открытый ключ " + "(" + f'{int(e)}' + "," + f'{n}' + ")")
    C1 = str((int(FIO_code[0]) ** int(e)) % n)
    C2 = str((int(FIO_code[1]) ** int(e)) % n)
    C3 = str((int(FIO_code[2]) ** int(e)) % n)
    print("C1=" + C1, "C2=" + C2, "C3=" + C3, sep="\n")
    print("3.Расшифрование:")
    M1 = str((int(C1) ** d) % n)
    M2 = str((int(C2) ** d) % n)
    M3 = str((int(C3) ** d) % n)
    print("M1=" + M1, "M2=" + M2, "M3=" + M3, sep="\n")
    result = dictonary_2[int(M1)] + dictonary_2[int(M2)] + dictonary_2[int(M3)]
    print("Исходное сообщение - " + result)


def HASH(SN, p, q, H0):
    n = p * q
    global H
    print("1. n=" + str(n))
    print("Вектор инициализации H0:" + str(H0))
    print("Хэшируем сообщение:")
    M = []
    for i in range(len(SN)):
        M.append(dictonary[SN[i]])
        print("M" + f'{i + 1}' + "=" + str(M[i]))
    print("2.Рассчитаем хеш-образ сообщения: ")
    H = [H0]
    for i in range(1, len(M)+1):
        H.append(((H[i - 1] + M[i-1]) ** 2) % n)
        print("H"+f'{i}'+"="+str(H[i]))
    print("Хэш-образ " + f'{SN}' + "-" + str(H[len(H)-1]))
    return H

def DigitalSignature(HASH, p, q, d):
    print("Полученные ранне хэш-образ ссобщения: " + str(HASH))
    n = p * q
    print("n = " + str(n))
    f = (p-1)*(q-1)
    print("Функция Эйлера φ(n)= " + str(f))
    print("Закрытый ключ- " + str(d))
    k = 0
    e = 0.1
    while e != int(e):
        k += 1
        e = (f * k + 1) / d
    print("(" + f'{int(e)}' + "," + f'{n}' + ")" + "- открытый ключ")
    print("(" + f'{d}' + "," + f'{n}' + ")" + "- закрытый ключ")
    s = (HASH**d) % n
    H = (s**int(e)) % n
    print("ЭЦП: " + str(s))
    print("Значение H: " + str(H))


if __name__ == '__main__':
    print("Задание №1 Алгоритм шифрования DES")
    DES('ЧЕРНЫШЯН', 'ЮРЬЕВИЧЯ')
    print("-----------------------------------------------------------------------------------------------------")
    print("Задание №2 Алгоритм шифрования ГОСТ 28147-89")
    GOST('ЧЕРНЫШЯН', 'Юрьевич')
    print("-----------------------------------------------------------------------------------------------------")
    print("Задание №3 Алгоритм шифрования RSA")
    RSA("ЧЯЮ", 89, 13, 283)
    print("-----------------------------------------------------------------------------------------------------")
    print("Задание №4 Функция хеширования")
    HASH("ЧЕРНЫШ", 89, 13, 4)
    print("-----------------------------------------------------------------------------------------------------")
    print("Задание №5 Электронная цифровая подпись")
    DigitalSignature(H[len(H)-1], 89, 13, 239)

